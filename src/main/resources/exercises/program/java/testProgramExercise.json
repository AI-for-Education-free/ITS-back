{
  "source": "w3resource",
  "link": "https://www.w3resource.com/java-exercises/index.php",
  "subjectType": "JAVA",
  "test": "public static String middle(String str) {\n        int position;\n        int length;\n        if (str.length() % 2 == 0)\n        {\n            position = str.length() / 2 - 1;\n            length = 2;\n        }\n        else\n        {\n            position = str.length() / 2;\n            length = 1;\n        }\n        return str.substring(position, position + length);\n    }",
  "template":
  {
    "orderInTag": -1,
    "id": "",
    "initCode": "public class Solution {\n    public static  {\n\n    }\n}",
    "targetMethodName": "",
    "concepts": [
      ""
    ],
    "tags": [
      ""
    ],
    "exerciseContents": [
      {
        "contentType": "TEXT",
        "english": "",
        "chinese": "",
        "style": ""
      },
      {
        "contentType": "CODE",
        "code": ""
      }
    ],
    "answerContents": [
      {
        "contentType": "TEXT",
        "english": "Sample Solution:\n\nJava Code:",
        "chinese": "示例：\n\nJava代码：",
        "style": "BOLD"
      },
      {
        "contentType": "CODE",
        "code": ""
      }
    ],
    "explanationContents": [
      {
        "contentType": "TEXT",
        "english": "Flowchart:",
        "chinese": "流程图：",
        "style": "BOLD"
      },
      {
        "contentType": "IMAGE",
        "imageName": ""
      }
    ]
  },
  "exercises": [
    {
      "orderInTag": 1,
      "id": "608581282",
      "initCode": "public class Solution {\n    public static int calculateFactorial(int n) {\n\n    }\n}",
      "targetMethodName": "calculateFactorial",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to calculate the factorial of a given positive integer.",
          "chinese": "编写一个 Java 递归方法来计算给定正整数的阶乘。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class FactorialCalculator {\n\n  public static int calculateFactorial(int n) {\n    // Base case: factorial of 0 is 1\n    if (n == 0) {\n      return 1;\n    }\n\n    // Recursive case: multiply n with factorial of (n-1)\n    return n * calculateFactorial(n - 1);\n  }\n\n  public static void main(String[] args) {\n    int number = 7;\n    int factorial = calculateFactorial(number);\n    System.out.println(\"Factorial of \" + number + \" is: \" + factorial);\n    number = 12;\n    factorial = calculateFactorial(number);\n    System.out.println(\"\\nFactorial of \" + number + \" is: \" + factorial);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nFirst, we define a class \"FactorialCalculator\" that includes a recursive method calculateFactorial() to calculate the factorial of a given positive integer n.\n\nThe calculateFactorial() method follows the recursive factorial definition. It has two cases:\n\nBase case: If n is 0, it returns 1. This is the termination condition for recursion.\nRecursive case: For any positive n, it multiplies n with the factorial of n-1. This step is repeated recursively until n reaches 0.\nIn the main() method, we demonstrate the calculateFactorial() method by calculating the factorial of 7 and 12.",
          "chinese": "在上面的练习中——\n\n首先，我们定义一个“FactorialCalculator”类，其中包含一个递归方法calculateFactorial()来计算给定正整数n的阶乘。\n\ncalculateFactorial() 方法遵循递归阶乘定义。 它有两种情况：\n\n基本情况：如果n为0，则返回1。这是递归的终止条件。\n递归情况：对于任何正数 n，它将 n 与 n-1 的阶乘相乘。 递归地重复此步骤，直到 n 达到 0。\n在main()方法中，我们通过计算7和12的阶乘来演示calculateFactorial()方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-1.png"
        }
      ]
    },
    {
      "orderInTag": 2,
      "id": "280586190",
      "initCode": "public class Solution {\n    public static int calculateSum(int n) {\n\n    }\n}",
      "targetMethodName": "calculateSum",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to calculate the sum of all numbers from 1 to n.",
          "chinese": "编写一个Java递归方法来计算从1到n的所有数字的总和。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class SumCalculator {\n\n  public static int calculateSum(int n) {\n    // Base case: sum of 0 is 0\n    if (n == 0) {\n      return 0;\n    }\n\n    // Recursive case: add n with the sum of (n-1)\n    return n + calculateSum(n - 1);\n  }\n\n  public static void main(String[] args) {\n    int number = 7;\n    int sum = calculateSum(number);\n    System.out.println(\"Sum of numbers from 1 to \" + number + \" is: \" + sum);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nThe calculateSum() method follows the recursive definition of the sum. It has two cases:\n\nBase case: If the input n is 0, it returns 0. This is the termination condition for recursion.\nRecursive case: For any positive n, it adds n with the sum of the numbers from 1 to n-1. This step is repeated recursively until n reaches 0\nIn the main() method, we demonstrate the calculateSum() method by calculating the sum of numbers from 1 to 7 and printing the result.",
          "chinese": "在上面的练习中——\n\ncalculateSum() 方法遵循总和的递归定义。 它有两种情况：\n\n基本情况：如果输入n为0，则返回0。这是递归的终止条件。\n递归情况：对于任何正数 n，它将 n 与 1 到 n-1 之间的数字之和相加。 递归地重复此步骤，直到 n 达到 0\n在 main() 方法中，我们通过计算 1 到 7 之间的数字之和并打印结果来演示calculateSum() 方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-2.png"
        }
      ]
    },
    {
      "orderInTag": 3,
      "id": "2136089454",
      "initCode": "public class Solution {\n    public static int calculateFibonacci(int n) {\n\n    }\n}",
      "targetMethodName": "calculateFibonacci",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to calculate the nth Fibonacci number.",
          "chinese": "编写一个Java递归方法来计算第n个斐波那契数。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class FibonacciCalculator {\n\n  public static int calculateFibonacci(int n) {\n    // Base case: Fibonacci numbers at positions 0 and 1 are 0 and 1, respectively\n    if (n == 0) {\n      return 0;\n    } else if (n == 1) {\n      return 1;\n    }\n\n    // Recursive case: sum of the previous two Fibonacci numbers\n    return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n  }\n\n  public static void main(String[] args) {\n    int position = 0;\n    int fibonacciNumber = calculateFibonacci(position);\n    System.out.println(\"The Fibonacci number at position \" + position + \" is: \" + fibonacciNumber);\n    position = 3;\n    fibonacciNumber = calculateFibonacci(position);\n    System.out.println(\"\\nThe Fibonacci number at position \" + position + \" is: \" + fibonacciNumber);\n    position = 9;\n    fibonacciNumber = calculateFibonacci(position);\n    System.out.println(\"\\nThe Fibonacci number at position \" + position + \" is: \" + fibonacciNumber);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nThe \"calculateFibonacci()\" method follows the recursive definition of the Fibonacci sequence. It has two cases:\n\ncase 1: If n is 0, it returns 0.\ncase 2: If n is 1, it returns 1.\nThese are the termination conditions for recursion.\n\nFor any positive n greater than 1, the method recursively calculates the Fibonacci number by summing the previous two Fibonacci numbers (calculated using the same method). This process is repeated until n reaches one of the base cases.\n\nIn the main() method, we demonstrate the calculateFibonacci() method by calculating the Fibonacci number at position 8 and printing the result.",
          "chinese": "在上面的练习中——\n\n“calculateFibonacci()”方法遵循斐波那契数列的递归定义。 它有两种情况：\n\n情况1：如果n为0，则返回0。\n情况 2：如果 n 为 1，则返回 1。\n这些是递归的终止条件。\n\n对于任何大于 1 的正 n，该方法通过将前两个斐波那契数相加（使用相同的方法计算）来递归计算斐波那契数。 重复此过程直到 n 达到基本情况之一。\n\n在main()方法中，我们通过计算位置8处的斐波那契数并打印结果来演示calculateFibonacci()方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-3.png"
        }
      ]
    },
    {
      "orderInTag": 4,
      "id": "288908044",
      "initCode": "public class Solution {\n    public static boolean isPalindrome(String str) {\n\n    }\n}",
      "targetMethodName": "isPalindrome",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to check if a given string is a palindrome.",
          "chinese": "编写一个 Java 递归方法来检查给定字符串是否为回文。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class PalindromeChecker {\n\n  public static boolean isPalindrome(String str) {\n    // Base case: an empty string or a string with one character is a palindrome\n    if (str.length() <= 1) {\n      return true;\n    }\n\n    // Recursive case: check if the first and last characters are equal,\n    // and recursively check if the substring between them is a palindrome\n    char firstChar = str.charAt(0);\n    char lastChar = str.charAt(str.length() - 1);\n\n    if (firstChar != lastChar) {\n      return false;\n    }\n\n    String remainingSubstring = str.substring(1, str.length() - 1);\n    return isPalindrome(remainingSubstring);\n  }\n\n  public static void main(String[] args) {\n    String palindrome1 = \"madam\";\n    boolean isPalindrome1 = isPalindrome(palindrome1);\n    System.out.println(palindrome1 + \" is a palindrome: \" + isPalindrome1);\n\n    String palindrome2 = \"level\";\n    boolean isPalindrome2 = isPalindrome(palindrome2);\n    System.out.println(palindrome2 + \" is a palindrome: \" + isPalindrome2);\n\n    String notPalindrome = \"java\";\n    boolean isPalindrome3 = isPalindrome(notPalindrome);\n    System.out.println(notPalindrome + \" is a palindrome: \" + isPalindrome3);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nWe define a class \"PalindromeChecker\" that includes a recursive method isPalindrome() to check if a given string str is a palindrome.\n\nThe isPalindrome() method has two cases:\n\nBase case: If the string length is 0 or 1, it returns true because an empty string or a string with one character is considered a palindrome.\nRecursive case: It compares the first and last characters of the string. If they are not equal, it returns false. Otherwise, it extracts the remaining substring between the first and last characters, and recursively checks if this substring is a palindrome. This process continues until the string is reduced to an empty string or one character.\nIn the main() method, we demonstrate the isPalindrome() method by checking if different strings are palindromes and printing the results.",
          "chinese": "在上面的练习中——\n\n我们定义一个类“PalindromeChecker”，其中包含一个递归方法 isPalindrome() 来检查给定字符串 str 是否是回文。\n\nisPalindrome()方法有两种情况：\n\n基本情况：如果字符串长度为 0 或 1，则返回 true，因为空字符串或只有一个字符的字符串被视为回文。\n递归情况：比较字符串的第一个和最后一个字符。 如果它们不相等，则返回 false。 否则，它提取第一个和最后一个字符之间的剩余子字符串，并递归检查该子字符串是否是回文。 这一过程持续进行，直到字符串减少为空字符串或一个字符。\n在 main() 方法中，我们通过检查不同字符串是否是回文并打印结果来演示 isPalindrome() 方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-4.png"
        }
      ]
    },
    {
      "orderInTag": 5,
      "id": "1214612750",
      "initCode": "public class Solution {\n    public static double calculateExponentiation(double base, int exponent) {\n\n    }\n}",
      "targetMethodName": "calculateExponentiation",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to calculate the exponentiation of a number (base) raised to a power (exponent).\n\n",
          "chinese": "编写一个 Java 递归方法来计算数字（底数）的幂（指数）的幂。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class ExponentiationCalculator {\n\n  public static double calculateExponentiation(double base, int exponent) {\n    // Base case: any number raised to the power of 0 is 1\n    if (exponent == 0) {\n      return 1;\n    }\n\n    // Recursive case: multiply the base with the exponentiation of (base, exponent-1)\n    return base * calculateExponentiation(base, exponent - 1);\n  }\n\n  public static void main(String[] args) {\n    double base = 3.5;\n    int exponent = 4;\n    double result = calculateExponentiation(base, exponent);\n    System.out.println(base + \" raised to the power of \" + exponent + \" is: \" + result);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nThe \"calculateExponentiation()\" method follows the recursive definition of exponentiation. It has two cases:\n\nBase case: If the exponent is 0, it returns 1. This is because any number raised to the power of 0 is equal to 1.\nRecursive case: For any positive exponent \"exponent\", it multiplies the base with the exponentiation of the same base raised to the power of exponent-1. This process is repeated recursively until the exponent reaches 0.\nIn the main() method, we demonstrate the calculateExponentiation() method by calculating the exponentiation of a base number (3.5) raised to a power (4) and printing the result.",
          "chinese": "在上面的练习中——\n\n“calculateExponentiation()”方法遵循求幂的递归定义。 它有两种情况：\n\n基本情况：如果指数为 0，则返回 1。这是因为任何数字的 0 次方都等于 1。\n递归情况：对于任何正指数“指数”，它将底数乘以相同底数的指数 1 次幂。 递归地重复这个过程，直到指数达到 0。\n在 main() 方法中，我们通过计算基数 (3.5) 的幂 (4) 的幂并打印结果来演示calculateExponentiation() 方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-5.png"
        }
      ]
    },
    {
      "orderInTag": 6,
      "id": "1106882667",
      "initCode": "public class Solution {\n    public static String reverseString(String str) {\n\n    }\n}",
      "targetMethodName": "reverseString",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to reverse a given string.",
          "chinese": "编写一个 Java 递归方法来反转给定的字符串。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class StringReverser {\n\n  public static String reverseString(String str) {\n    // Base case: if the string is empty or has only one character, it is already reversed\n    if (str.isEmpty() || str.length() == 1) {\n      return str;\n    }\n\n    // Recursive case: reverse the substring starting from the second character and concatenate the first character\n    return reverseString(str.substring(1)) + str.charAt(0);\n  }\n\n  public static void main(String[] args) {\n    String input = \"Java, World!\";\n    String reversed = reverseString(input);\n    System.out.println(\"Original string: \" + input);\n    System.out.println(\"Reversed string: \" + reversed);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nFirst, we define a class \"StringReverser\" that includes a recursive method reverseString() to reverse a given string str.\n\nThe reverseString() method has two cases:\n\nBase case: If the string is empty or has only one character, it is already reversed, so we return the original string.\nRecursive case: For any string with length greater than 1, we recursively reverse the substring starting with the second character and concatenate the first character at the end. This process continues until the string is reduced to an empty string or one character.\nIn the main() method, we demonstrate the reverseString() method by reversing the string \"Java, World!\" and printing both the original and reversed strings.",
          "chinese": "在上面的练习中——\n\n首先，我们定义一个“StringReverser”类，其中包含一个递归方法reverseString()来反转给定的字符串str。\n\nverseString()方法有两种情况：\n\n基本情况：如果字符串为空或只有一个字符，则它已经反转，因此我们返回原始字符串。\n递归情况：对于任何长度大于1的字符串，我们递归地反转从第二个字符开始的子字符串，并在末尾连接第一个字符。 这一过程持续进行，直到字符串减少为空字符串或一个字符。\n在main()方法中，我们通过反转字符串“Java, World!”来演示reverseString()方法。 并打印原始字符串和反转字符串。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-6.png"
        }
      ]
    },
    {
      "orderInTag": 7,
      "id": "1228848010",
      "initCode": "public class Solution {\n    public static int calculateGCD(int num1, int num2) {\n\n    }\n}",
      "targetMethodName": "calculateGCD",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to find the greatest common divisor (GCD) of two numbers.",
          "chinese": "编写一个 Java 递归方法来查找两个数字的最大公约数 (GCD)。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class GCDCalculator {\n\n  public static int calculateGCD(int num1, int num2) {\n    // Base case: if the second number is 0, the GCD is the first number\n    if (num2 == 0) {\n      return num1;\n    }\n\n    // Recursive case: calculate the GCD by recursively calling the method with num2 as the new num1 and the remainder as num2\n    int remainder = num1 % num2;\n    return calculateGCD(num2, remainder);\n  }\n\n  public static void main(String[] args) {\n    int number1 = 16;\n    int number2 = 18;\n    int gcd = calculateGCD(number1, number2);\n    System.out.println(\"The GCD of \" + number1 + \" and \" + number2 + \" is: \" + gcd);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nFirst, we define a class GCDCalculator that includes a recursive method calculateGCD() to find the greatest common divisor (GCD) of two numbers.\n\nThe calculateGCD() method follows the recursive GCD definition. It has two cases:\n\nBase case: If the second number (num2) is 0, the GCD is the first number (num1). This is because any number divided by 0 is the number itself.\nRecursive case: For any two numbers (num1 and num2), we calculate the remainder when num1 is divided by num2. We then recursively call the method with num2 as the new num1 and the remainder as num2. This process continues until num2 reaches 0.\nIn the main() method, we demonstrate the calculateGCD() method by finding the GCD of two numbers (16 and 18) and printing the result.",
          "chinese": "在上面的练习中——\n\n首先，我们定义一个类 GCDCalculator，其中包含一个递归方法calculateGCD()来查找两个数字的最大公约数（GCD）。\n\ncalculateGCD() 方法遵循递归 GCD 定义。 它有两种情况：\n\n基本情况：如果第二个数字 (num2) 为 0，则 GCD 为第一个数字 (num1)。 这是因为任何数字除以 0 就是数字本身。\n递归情况：对于任意两个数字（num1 和 num2），我们计算 num1 除以 num2 时的余数。 然后，我们递归调用该方法，将 num2 作为新的 num1，将余数作为 num2。 这个过程一直持续到 num2 达到 0。\n在 main() 方法中，我们通过查找两个数字（16 和 18）的 GCD 并打印结果来演示calculateGCD() 方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-7.png"
        }
      ]
    },
    {
      "orderInTag": 9,
      "id": "89064573",
      "initCode": "public class Solution {\n    public static int calculateOddNumberSum(int[] arr) {\n\n    }\n}",
      "targetMethodName": "calculateOddNumberSum",
      "concepts": [
        "recursive methods"
      ],
      "tags": [
        "recursive methods"
      ],
      "exerciseContents": [
        {
          "contentType": "TEXT",
          "english": "Write a Java recursive method to find the sum of all odd numbers in an array.",
          "chinese": "编写一个 Java 递归方法来查找数组中所有奇数的总和。",
          "style": ""
        }
      ],
      "answerContents": [
        {
          "contentType": "TEXT",
          "english": "Sample Solution:\n\nJava Code:",
          "chinese": "示例：\n\nJava代码：",
          "style": "BOLD"
        },
        {
          "contentType": "CODE",
          "code": "public class OddNumberSumCalculator {\n\n  public static int calculateOddNumberSum(int[] arr) {\n    return calculateOddNumberSum(arr, 0);\n  }\n\n  private static int calculateOddNumberSum(int[] arr, int index) {\n    // Base case: if the index reaches the end of the array, return 0\n    if (index == arr.length) {\n      return 0;\n    }\n\n    // Recursive case: check if the element at the current index is odd,\n    // and recursively call the method with the next index and add the current element if it is odd\n    int sum = calculateOddNumberSum(arr, index + 1);\n    if (arr[index] % 2 != 0) {\n      sum += arr[index];\n    }\n\n    return sum;\n  }\n\n  public static void main(String[] args) {\n    int[] numbers = {\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9\n    };\n    int sum = calculateOddNumberSum(numbers);\n    System.out.println(\"The sum of all odd numbers in the array is: \" + sum);\n  }\n}"
        }
      ],
      "explanationContents": [
        {
          "contentType": "TEXT",
          "english": "Explanation:",
          "chinese": "解释：",
          "style": "BOLD"
        },
        {
          "contentType": "TEXT",
          "english": "In the above exercises -\n\nFirst, we define a class OddNumberSumCalculator that includes a recursive method calculateOddNumberSum() to find the sum of all odd numbers in an array.\n\nThe calculateOddNumberSum() method has two cases:\n\nBase case: If the index reaches the end of the array (index == arr.length), we return 0 as there are no more elements to check.\nRecursive case: For any index that is within the bounds of the array, we check if the element at that index is odd. We then recursively call the method with the next index and add the current element to the sum if it is odd. This process continues until we reach the end of the array.\nIn the main() method, we demonstrate the calculateOddNumberSum() method by finding the sum of all odd numbers in the array [1, 2, 3, 4, 5, 6, 7, 8, 9] and printing the result.",
          "chinese": "在上面的练习中——\n\n首先，我们定义一个类 OddNumberSumCalculator，其中包含一个递归方法calculateOddNumberSum()，用于查找数组中所有奇数的总和。\n\ncalculateOddNumberSum()方法有两种情况：\n\n基本情况：如果索引到达数组末尾（index == arr.length），我们返回 0，因为没有更多元素需要检查。\n递归情况：对于数组边界内的任何索引，我们检查该索引处的元素是否为奇数。 然后，我们使用下一个索引递归调用该方法，如果当前元素是奇数，则将当前元素添加到总和中。 这个过程一直持续到我们到达数组的末尾。\n在 main() 方法中，我们通过查找数组 [1, 2, 3, 4, 5, 6, 7, 8, 9] 中所有奇数的总和并打印结果来演示calculateOddNumberSum() 方法。",
          "style": ""
        },
        {
          "contentType": "TEXT",
          "english": "Flowchart:",
          "chinese": "流程图：",
          "style": "BOLD"
        },
        {
          "contentType": "IMAGE",
          "imageName": "java-recursive-exercise-flowchart-9.png"
        }
      ]
    }
  ]
}